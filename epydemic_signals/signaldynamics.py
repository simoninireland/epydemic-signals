# A mixin to tap the event stream of a dynamics to a signal generator
#
# Copyright (C) 2021 Simon Dobson
#
# This file is part of epydemic-signals, an experiment in epidemic processes.
#
# epydemic-signals is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# epydemic-signals is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with epydemic-signals. If not, see <http://www.gnu.org/licenses/gpl.html>.

import sys
from epydemic import Element
from epydemic_signals import SignalGenerator, Signal
from typing import Dict, Any, Tuple, Union, List
if sys.version_info >= (3, 8):
    from typing import Final
else:
    from typing_extensions import Final

class SignalExperiment:
    '''A mixin class used to add a "tap" for an event stream to a
    :class:`epydedmic:NetworkExperiment` sub-class.'''

    # Results
    SIGNALS: Final[str] = 'epydemic.signals'      #: Result holding names of signals generated.

    # Result names stem
    SIGNAL_STEM: Final[str] = 'epydemic.signal'   #: Stem for names of timeseries generated by signals.

    @staticmethod
    def signalSeriesElement(s: Signal, l: str) -> str:
        '''Generate the name of a result for a signal.

        :param s: the signal
        :param l: the element of the time series
        :returns: a result name'''
        return '{stem}.{n}.{l}'.format(stem=SignalExperiment.SIGNAL_STEM, n=s.name(), l=l)

    @staticmethod
    def signalSeries(s: Signal) -> Tuple[str, str, str]:
        '''Return the result names of the three time series representing
        a signal: the update times, elements, and values.

        :param s: the signal
        :returns: a triple of three resuilt names'''
        return (SignalExperiment.signalSeriesElement(s, 't'),
                SignalExperiment.signalSeriesElement(s, 'e'),
                SignalExperiment.signalSeriesElement(s, 'v'))


    # ---------- Taps management ----------

    def initialiseEventTaps(self):
        '''Set up the signal generation tap framework. This overrides the
        method inherited from :class:`NetworkDynamics` andd which is called
        from that class' constructor.'''
        self._signalGenerators = []

    def addSignalGenerator(self, gen: SignalGenerator):
        '''Add a signal generator that will be passed events.

        :param gen: the signal generator'''
        self._signalGenerators.append(gen)
        gen.setExperiment(self)


    # ---------- Signals to results ----------

    def reportSignal(self, s: Signal, res: Dict[str, Any]):
        '''Add the given signal to the results. This is the bridge from
        signals to ``epydemic``'s normal results mechanism, encoding the
        signal in a form suitable for a lab notebook.

        :param s: the signal
        :param res: the results dict'''
        (ts, es, vs) = s.toUpdates()
        if len(ts) > 0:
            # we have some signal to record
            (tn, en, vn) = SignalExperiment.signalSeries(s)
            res[tn] = ts
            res[en] = es
            res[vn] = vs


    # ---------- Tap method overrides ----------

    def simulationStarted(self, params: Dict[str, Any]):
        '''Notify the signal generators that the simulation has started.
        Each generatopr is passed the experimental parameters and the
        network associated with the experiment.

        :param params: the experimental parameters'''
        g = self.network()
        for gen in self._signalGenerators:
            gen.setUp(g, params)

    def simulationEnded(self, res: Union[Dict[str, Any], List[Dict[str, Any]]]):
        '''Notify the signal generators that the simulation has ended. This
        packs-up all signals into the results dict, along with an entry containing
        the names of all the signals.

        :param res: the experimental results'''
        signals = []
        for gen in self._signalGenerators:
            signal = gen.signal()
            signals.append(signal.name())
            self.reportSignal(signal, res)
            gen.tearDown()
        res[self.SIGNALS] = signals

    def eventFired(self, t: float, etype: str, e: Element):
        '''Pass a fired event to the signal generators.

        :param t: the simulation time
        :param etype: the event type
        :param e: the element'''
        for gen in self._signalGenerators:
            gen.event(t, etype, e)
