# A mixin to tap the event stream of a dynamics to a signal generator
#
# Copyright (C) 2021--2022 Simon Dobson
#
# This file is part of epydemic-signals, an experiment in epidemic processes.
#
# epydemic-signals is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# epydemic-signals is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with epydemic-signals. If not, see <http://www.gnu.org/licenses/gpl.html>.

import sys
from pandas import Series
from epydemic import Element, Process
from epydemic_signals import SignalGenerator, Signal
from typing import Dict, Any, Tuple, Union, List
if sys.version_info >= (3, 8):
    from typing import Final
else:
    from typing_extensions import Final


class SignalExperiment:
    '''A mixin class used to add a "tap" for an event stream to a
    :class:`epydedmic:NetworkExperiment` sub-class.'''

    # Results
    SIGNALS: Final[str] = 'epydemic.signals'      #: Result holding names of signals generated.

    # Result names stem
    SIGNAL_STEM: Final[str] = 'epydemic.signal'   #: Stem for names of timeseries generated by signals.


    # ---------- Result encoding and decoding ----------

    # sd: extend with process name/id/whatever

    @staticmethod
    def signalSeriesElement(s: Signal, l: str) -> str:
        '''Generate the name of a result for a signal.

        :param s: the signal
        :param l: the element of the time series
        :returns: a result name'''
        return '{stem}.{n}.{l}'.format(stem=SignalExperiment.SIGNAL_STEM, n=s.name(), l=l)

    @staticmethod
    def signalSeries(s: Signal) -> Tuple[str, str, str]:
        '''Return the result names of the three time series representing
        a signal: the update times, elements, and values.

        :param s: the signal
        :returns: a triple of three resuilt names'''
        return (SignalExperiment.signalSeriesElement(s, 't'),
                SignalExperiment.signalSeriesElement(s, 'e'),
                SignalExperiment.signalSeriesElement(s, 'v'))

    @staticmethod
    def signals(df: Series) -> List[Signal]:
        '''Extract all the signals encoded in a ``pandas.Series``. This
        may of course be none.

        The signals are extracted by looking for an entry for a list of
        signals in the :attr:`SIGNALS` column. If found, these are used to
        extract the signal time series and build a signal.

        The order in which the signals appear in the list is undefined,
        although likely to be that in which the generators were added
        to the experiment.

        :param df: a Series
        :returns: a (possibly empty) list of signals'''
        if SignalExperiment.SIGNALS not in df:
            return []

        ns = df[SignalExperiment.SIGNALS]
        signals = []
        for n in ns:
            s = Signal(name=n)
            signals.append(s.fromSeries(df))
        return signals


    # ---------- Taps management ----------

    def initialiseEventTaps(self):
        '''Set up the signal generation tap framework. This overrides the
        method inherited from :class:`NetworkDynamics` and which is called
        from that class' constructor.'''
        self._signalGenerators : Dict[Process, List[SignalGenerator]] = {}

    def attachSignalGenerator(self, gen: SignalGenerator, p: Process):
        '''Attach a signal generator to a specific process instance. The generator
        will receive those events it registers for from this process (and none
        from any opther processes).

        :param gen: the signal generator
        :param p: the process'''
        if p not in self._signalGenerators:
            self._signalGenerators[p] = []
        self._signalGenerators[p].append(gen)
        gen.setExperiment(self)
        gen.setProcess(p)


    # ---------- Signals to results ----------

    def reportSignal(self, s: Signal, res: Dict[str, Any]) -> bool:
        '''Add the given signal to the results. This is the bridge from
        signals to ``epydemic``'s normal results mechanism, encoding the
        signal in a form suitable for a lab notebook.

        :param s: the signal
        :param res: the results dict
        :returns: True if there were results added'''
        (ts, es, vs) = s.toUpdates()
        if len(ts) > 0:
            # we have some signal to record
            (tn, en, vn) = SignalExperiment.signalSeries(s)
            res[tn] = ts
            res[en] = es
            res[vn] = vs
        return (len(ts) > 0)


    # ---------- Tap method overrides ----------

    def simulationStarted(self, params: Dict[str, Any]):
        '''Notify the signal generators that the simulation has started.
        Each generatopr is passed the experimental parameters and the
        network associated with the experiment.

        :param params: the experimental parameters'''
        g = self.network()
        for p in self._signalGenerators.keys():
            for gen in self._signalGenerators[p]:
                gen.setUp(g, params)

    def simulationEnded(self, res: Union[Dict[str, Any], List[Dict[str, Any]]]):
        '''Notify the signal generators that the simulation has ended. This
        packs-up all signals into the results dict, along with an entry containing
        the names of all the signals.

        :param res: the experimental results'''
        signals = []
        for p in self._signalGenerators.keys():
            for gen in self._signalGenerators[p]:
                signal = gen.signal()
                if self.reportSignal(signal, res):
                    signals.append(signal.name())
                gen.tearDown()
        if len(signals) > 0:
            res[self.SIGNALS] = signals

    def eventFired(self, t: float, p: Process, etype: str, e: Element):
        '''Pass a fired event to the signal generators attached to that
        process. Only the attached geberators will receive the event, not
        generatorsd attached to other processes.

        :param t: the simulation time
        :param p: the process that initiated the event
        :param etype: the event type
        :param e: the element'''
        if p in self._signalGenerators.keys():
            for gen in self._signalGenerators[p]:
                gen.event(t, etype, e)
